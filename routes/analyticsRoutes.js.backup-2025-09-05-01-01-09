/**
 * Rotas de Analytics e Monitoramento
 * ETAPA 5 - Analytics e Monitoramento
 */

const express = require('express');
const router = express.Router();
const analyticsCollector = require('../src/utils/analytics');
const systemMonitor = require('../src/utils/monitoring');
const { getMetrics } = require('../src/utils/metrics');
const { info, security } = require('../src/utils/logger');

// Middleware de autenticaÃ§Ã£o para rotas administrativas
const requireAdmin = (req, res, next) => {
  const adminToken = req.headers['x-admin-token'];
  const env = require('../config/env');
  
  if (!adminToken || adminToken !== env.ADMIN_TOKEN) {
    security('UNAUTHORIZED_ANALYTICS_ACCESS', {
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      attemptedRoute: req.path
    });
    
    return res.status(401).json({
      error: 'Acesso negado',
      message: 'Token de administrador necessÃ¡rio'
    });
  }
  
  next();
};

// ===== MÃ‰TRICAS EM TEMPO REAL =====

// Dashboard principal de mÃ©tricas
router.get('/dashboard', requireAdmin, async (req, res) => {
  try {
    const metrics = systemMonitor.getMetrics();
    const realTimeMetrics = analyticsCollector.getRealTimeMetrics();
    const alerts = systemMonitor.getActiveAlerts();
    
    const dashboard = {
      timestamp: new Date().toISOString(),
      system: {
        status: metrics.status,
        uptime: metrics.system.uptime,
        cpu: metrics.system.cpu,
        memory: metrics.system.memory,
        loadAverage: metrics.system.loadAverage
      },
      application: {
        activeUsers: realTimeMetrics.activeUsers,
        activeGames: realTimeMetrics.activeGames,
        totalBets: realTimeMetrics.totalBets,
        errorRate: metrics.application.errorRate,
        averageResponseTime: metrics.application.averageResponseTime
      },
      business: {
        totalRevenue: realTimeMetrics.totalRevenue,
        conversionRate: realTimeMetrics.conversionRate,
        averageGameDuration: realTimeMetrics.averageGameDuration
      },
      alerts: {
        count: alerts.length,
        critical: alerts.filter(a => a.severity === 'critical').length,
        warning: alerts.filter(a => a.severity === 'warning').length,
        recent: alerts.slice(0, 5)
      }
    };
    
    info('DASHBOARD_ACCESSED', { adminToken: req.headers['x-admin-token']?.substring(0, 10) });
    
    res.json({
      success: true,
      data: dashboard
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao obter mÃ©tricas do dashboard',
      message: error.message
    });
  }
});

// MÃ©tricas do Prometheus
router.get('/metrics', requireAdmin, async (req, res) => {
  try {
    const metrics = await getMetrics();
    
    res.set('Content-Type', 'text/plain');
    res.send(metrics);
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao obter mÃ©tricas do Prometheus',
      message: error.message
    });
  }
});

// ===== ANALYTICS DE NEGÃ“CIO =====

// RelatÃ³rio diÃ¡rio
router.get('/reports/daily', requireAdmin, async (req, res) => {
  try {
    const report = analyticsCollector.generateDailyReport();
    
    res.json({
      success: true,
      data: report
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao gerar relatÃ³rio diÃ¡rio',
      message: error.message
    });
  }
});

// HistÃ³rico de eventos
router.get('/events', requireAdmin, async (req, res) => {
  try {
    const { type, limit = 100 } = req.query;
    const events = analyticsCollector.getEventHistory(type, parseInt(limit));
    
    res.json({
      success: true,
      data: {
        events,
        count: events.length,
        type: type || 'all'
      }
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao obter histÃ³rico de eventos',
      message: error.message
    });
  }
});

// EstatÃ­sticas de usuÃ¡rios
router.get('/users/stats', requireAdmin, async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    
    // Implementar consulta ao banco para estatÃ­sticas de usuÃ¡rios
    const stats = {
      totalUsers: 0,
      activeUsers: 0,
      newUsers: 0,
      retentionRate: 0,
      averageSessionDuration: 0,
      topCountries: [],
      userGrowth: []
    };
    
    res.json({
      success: true,
      data: stats
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao obter estatÃ­sticas de usuÃ¡rios',
      message: error.message
    });
  }
});

// EstatÃ­sticas de jogos
router.get('/games/stats', requireAdmin, async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    
    // Implementar consulta ao banco para estatÃ­sticas de jogos
    const stats = {
      totalGames: 0,
      activeGames: 0,
      completedGames: 0,
      averageGameDuration: 0,
      popularGameTypes: [],
      gameCompletionRate: 0
    };
    
    res.json({
      success: true,
      data: stats
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao obter estatÃ­sticas de jogos',
      message: error.message
    });
  }
});

// EstatÃ­sticas de apostas
router.get('/bets/stats', requireAdmin, async (req, res) => {
  try {
    const { startDate, endDate } = req.query;
    
    // Implementar consulta ao banco para estatÃ­sticas de apostas
    const stats = {
      totalBets: 0,
      totalAmount: 0,
      averageBetAmount: 0,
      winRate: 0,
      popularBetTypes: [],
      topWinners: []
    };
    
    res.json({
      success: true,
      data: stats
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao obter estatÃ­sticas de apostas',
      message: error.message
    });
  }
});

// ===== MONITORAMENTO DO SISTEMA =====

// Status de saÃºde do sistema
router.get('/health', requireAdmin, async (req, res) => {
  try {
    const healthReport = systemMonitor.generateHealthReport();
    
    const statusCode = healthReport.status === 'healthy' ? 200 : 
                      healthReport.status === 'warning' ? 200 : 503;
    
    res.status(statusCode).json({
      success: true,
      data: healthReport
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao verificar saÃºde do sistema',
      message: error.message
    });
  }
});

// Alertas ativos
router.get('/alerts', requireAdmin, async (req, res) => {
  try {
    const alerts = systemMonitor.getAlerts();
    const activeAlerts = systemMonitor.getActiveAlerts();
    
    res.json({
      success: true,
      data: {
        active: activeAlerts,
        all: alerts,
        count: {
          total: alerts.length,
          active: activeAlerts.length,
          critical: activeAlerts.filter(a => a.severity === 'critical').length,
          warning: activeAlerts.filter(a => a.severity === 'warning').length
        }
      }
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao obter alertas',
      message: error.message
    });
  }
});

// ConfiguraÃ§Ã£o de thresholds
router.get('/thresholds', requireAdmin, async (req, res) => {
  try {
    const thresholds = systemMonitor.thresholds;
    
    res.json({
      success: true,
      data: thresholds
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao obter thresholds',
      message: error.message
    });
  }
});

router.put('/thresholds', requireAdmin, async (req, res) => {
  try {
    const { type, value } = req.body;
    
    if (!type || value === undefined) {
      return res.status(400).json({
        success: false,
        error: 'Tipo e valor sÃ£o obrigatÃ³rios'
      });
    }
    
    systemMonitor.updateThreshold(type, value);
    
    res.json({
      success: true,
      message: 'Threshold atualizado com sucesso',
      data: { type, value }
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao atualizar threshold',
      message: error.message
    });
  }
});

// ===== MÃ‰TRICAS PERSONALIZADAS =====

// Registrar mÃ©trica personalizada
router.post('/metrics/custom', requireAdmin, async (req, res) => {
  try {
    const { name, value, metadata } = req.body;
    
    if (!name || value === undefined) {
      return res.status(400).json({
        success: false,
        error: 'Nome e valor sÃ£o obrigatÃ³rios'
      });
    }
    
    systemMonitor.recordCustomMetric(name, value, metadata);
    
    res.json({
      success: true,
      message: 'MÃ©trica registrada com sucesso'
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Erro ao registrar mÃ©trica',
      message: error.message
    });
  }
});

// ===== ENDPOINTS PÃšBLICOS (SEM AUTENTICAÃ‡ÃƒO) =====

// Status bÃ¡sico do sistema (pÃºblico)
router.get('/status', async (req, res) => {
  try {
    const metrics = systemMonitor.getMetrics();
    
    res.json({
      status: metrics.status,
      uptime: metrics.system.uptime,
      timestamp: new Date().toISOString(),
      version: process.env.npm_package_version || '1.0.0'
    });
    
  } catch (error) {
    res.status(500).json({
      status: 'error',
      message: 'Erro ao obter status do sistema'
    });
  }
});

module.exports = router;


// ===== ROTAS DE IA/ML - RECOMENDAÇÕES PERSONALIZADAS =====

// Armazenar dados de analytics (em produção, usar banco de dados)
const playerAnalytics = new Map();

// Obter analytics do jogador
router.get('/player/:userId', (req, res) => {
  try {
    const { userId } = req.params;
    const analytics = playerAnalytics.get(userId) || {
      gameHistory: [],
      patterns: {},
      recommendations: [],
      lastUpdated: null
    };

    res.json(analytics);
  } catch (error) {
    console.error('Erro ao obter analytics:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Atualizar analytics do jogador
router.post('/player/:userId', (req, res) => {
  try {
    const { userId } = req.params;
    const { gameData } = req.body;

    const currentAnalytics = playerAnalytics.get(userId) || {
      gameHistory: [],
      patterns: {},
      recommendations: [],
      lastUpdated: null
    };

    // Adicionar novo jogo ao histórico
    const newGame = {
      ...gameData,
      timestamp: new Date().toISOString()
    };

    const updatedHistory = [...currentAnalytics.gameHistory, newGame];
    
    // Manter apenas os últimos 100 jogos
    const recentHistory = updatedHistory.slice(-100);

    // Analisar padrões
    const patterns = analyzePlayerPatterns(recentHistory);
    
    // Gerar recomendações
    const recommendations = generateRecommendations(patterns);

    const updatedAnalytics = {
      gameHistory: recentHistory,
      patterns,
      recommendations,
      lastUpdated: new Date().toISOString()
    };

    playerAnalytics.set(userId, updatedAnalytics);

    res.json({ success: true, analytics: updatedAnalytics });
  } catch (error) {
    console.error('Erro ao atualizar analytics:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Obter recomendações do jogador
router.get('/recommendations/:userId', (req, res) => {
  try {
    const { userId } = req.params;
    const analytics = playerAnalytics.get(userId);
    
    if (!analytics) {
      return res.json({ recommendations: [] });
    }

    res.json({ recommendations: analytics.recommendations });
  } catch (error) {
    console.error('Erro ao obter recomendações:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Obter padrões do jogador
router.get('/patterns/:userId', (req, res) => {
  try {
    const { userId } = req.params;
    const analytics = playerAnalytics.get(userId);
    
    if (!analytics) {
      return res.json({ patterns: {} });
    }

    res.json({ patterns: analytics.patterns });
  } catch (error) {
    console.error('Erro ao obter padrões:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Obter estatísticas gerais
router.get('/stats/:userId', (req, res) => {
  try {
    const { userId } = req.params;
    const analytics = playerAnalytics.get(userId);
    
    if (!analytics) {
      return res.json({
        totalGames: 0,
        totalGoals: 0,
        successRate: 0,
        winStreak: 0,
        favoriteZone: null,
        bestTime: null,
        optimalBetAmount: 1.0
      });
    }

    const stats = {
      totalGames: analytics.patterns.totalGames || 0,
      totalGoals: analytics.patterns.totalGoals || 0,
      successRate: analytics.patterns.successRate || 0,
      winStreak: analytics.patterns.winStreak || 0,
      favoriteZone: analytics.patterns.favoriteZones?.[0] || null,
      bestTime: analytics.patterns.bestTimes?.[0] || null,
      optimalBetAmount: analytics.patterns.optimalBetAmount || 1.0,
      playingFrequency: analytics.patterns.playingFrequency || 'low',
      riskTolerance: analytics.patterns.riskTolerance || 'medium'
    };

    res.json(stats);
  } catch (error) {
    console.error('Erro ao obter estatísticas:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  }
});

// Funções auxiliares para análise de padrões
function analyzePlayerPatterns(gameHistory) {
  if (!gameHistory || gameHistory.length === 0) {
    return {
      favoriteZones: [],
      bestTimes: [],
      optimalBetAmount: 1.0,
      successRate: 0,
      winStreak: 0,
      playingFrequency: 'low',
      riskTolerance: 'medium',
      totalGames: 0,
      totalGoals: 0
    };
  }

  // Análise de zonas favoritas
  const zoneStats = {};
  gameHistory.forEach(game => {
    if (game.zone && game.isGoal) {
      zoneStats[game.zone] = (zoneStats[game.zone] || 0) + 1;
    }
  });
  
  const favoriteZones = Object.entries(zoneStats)
    .sort(([,a], [,b]) => b - a)
    .slice(0, 3)
    .map(([zone, count]) => ({
      zone: parseInt(zone),
      successCount: count,
      successRate: count / gameHistory.filter(g => g.zone === parseInt(zone)).length
    }));

  // Análise de horários
  const timeStats = {};
  gameHistory.forEach(game => {
    const hour = new Date(game.timestamp).getHours();
    const timeSlot = hour < 6 ? 'madrugada' : 
                    hour < 12 ? 'manhã' : 
                    hour < 18 ? 'tarde' : 'noite';
    
    if (!timeStats[timeSlot]) {
      timeStats[timeSlot] = { total: 0, goals: 0 };
    }
    timeStats[timeSlot].total++;
    if (game.isGoal) timeStats[timeSlot].goals++;
  });

  const bestTimes = Object.entries(timeStats)
    .map(([time, stats]) => ({
      time,
      successRate: stats.goals / stats.total,
      totalGames: stats.total
    }))
    .sort((a, b) => b.successRate - a.successRate)
    .slice(0, 2);

  // Análise de valores de aposta
  const betAmounts = gameHistory.map(g => g.amount).filter(Boolean);
  const optimalBetAmount = betAmounts.length > 0 
    ? betAmounts.reduce((a, b) => a + b, 0) / betAmounts.length
    : 1.0;

  // Taxa de sucesso geral
  const totalGames = gameHistory.length;
  const totalGoals = gameHistory.filter(g => g.isGoal).length;
  const successRate = totalGames > 0 ? totalGoals / totalGames : 0;

  // Sequência de vitórias atual
  let currentWinStreak = 0;
  for (let i = gameHistory.length - 1; i >= 0; i--) {
    if (gameHistory[i].isGoal) {
      currentWinStreak++;
    } else {
      break;
    }
  }

  // Frequência de jogo
  const now = new Date();
  const lastWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const recentGames = gameHistory.filter(g => 
    new Date(g.timestamp) > lastWeek
  ).length;
  
  const playingFrequency = recentGames > 20 ? 'high' : 
                        recentGames > 10 ? 'medium' : 'low';

  // Tolerância ao risco
  const avgBet = betAmounts.length > 0 ? betAmounts.reduce((a, b) => a + b, 0) / betAmounts.length : 1.0;
  const riskTolerance = avgBet > 5 ? 'high' : 
                     avgBet > 2 ? 'medium' : 'low';

  return {
    favoriteZones,
    bestTimes,
    optimalBetAmount: Math.round(optimalBetAmount * 100) / 100,
    successRate: Math.round(successRate * 100) / 100,
    winStreak: currentWinStreak,
    playingFrequency,
    riskTolerance,
    totalGames,
    totalGoals
  };
}

function generateRecommendations(patterns) {
  const recommendations = [];

  // Recomendação de zona favorita
  if (patterns.favoriteZones.length > 0) {
    const bestZone = patterns.favoriteZones[0];
    if (bestZone.successRate > 0.6) {
      recommendations.push({
        id: 'favorite_zone',
        type: 'zone',
        priority: 'high',
        title: 'Zona de Sucesso!',
        message: Você tem % de sucesso na zona . Continue apostando nela!,
        action: Apostar na zona ,
        confidence: bestZone.successRate,
        icon: '??'
      });
    }
  }

  // Recomendação de horário
  if (patterns.bestTimes.length > 0) {
    const bestTime = patterns.bestTimes[0];
    if (bestTime.successRate > 0.7) {
      recommendations.push({
        id: 'best_time',
        type: 'timing',
        priority: 'medium',
        title: 'Horário de Ouro',
        message: Sua taxa de sucesso é % durante a .,
        action: Jogar mais durante a ,
        confidence: bestTime.successRate,
        icon: '?'
      });
    }
  }

  // Recomendação de valor de aposta
  if (patterns.optimalBetAmount > 0) {
    recommendations.push({
      id: 'optimal_bet',
      type: 'betting',
      priority: 'medium',
      title: 'Valor Ideal',
      message: Seu valor médio de aposta é R$ . Considere manter esse valor!,
      action: Apostar R$ ,
      confidence: 0.8,
      icon: '??'
    });
  }

  // Recomendação de sequência de vitórias
  if (patterns.winStreak >= 3) {
    recommendations.push({
      id: 'win_streak',
      type: 'motivation',
      priority: 'high',
      title: 'Sequência Quente!',
      message: Você está em uma sequência de  vitórias! Continue assim!,
      action: 'Manter a estratégia atual',
      confidence: 0.9,
      icon: '??'
    });
  }

  // Recomendação de frequência de jogo
  if (patterns.playingFrequency === 'low' && patterns.successRate > 0.5) {
    recommendations.push({
      id: 'play_more',
      type: 'engagement',
      priority: 'low',
      title: 'Jogue Mais!',
      message: Sua taxa de sucesso é %. Que tal jogar mais vezes?,
      action: 'Aumentar frequência de jogo',
      confidence: patterns.successRate,
      icon: '??'
    });
  }

  // Recomendação de tolerância ao risco
  if (patterns.riskTolerance === 'low' && patterns.successRate > 0.6) {
    recommendations.push({
      id: 'increase_bet',
      type: 'betting',
      priority: 'low',
      title: 'Considere Apostar Mais',
      message: Com % de sucesso, você pode considerar apostas maiores.,
      action: 'Aumentar valor das apostas',
      confidence: patterns.successRate,
      icon: '??'
    });
  }

  return recommendations.sort((a, b) => {
    const priorityOrder = { high: 3, medium: 2, low: 1 };
    return priorityOrder[b.priority] - priorityOrder[a.priority];
  });
}
