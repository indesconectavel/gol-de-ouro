// SERVIDOR SIMPLIFICADO - GOL DE OURO v1.2.0 - DEPLOY FUNCIONAL
// ==============================================================
// Data: 21/10/2025
// Status: SERVIDOR SIMPLIFICADO PARA DEPLOY
// Vers√£o: v1.2.0-deploy-functional
// GPT-4o Auto-Fix: Backend funcional para deploy

const express = require('express');
const cors = require('cors');
const compression = require('compression');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const { createClient } = require('@supabase/supabase-js');
const axios = require('axios');
const { calculateInitialBalance, validateRealData, isProductionMode } = require('./config/system-config');

// Importar validadores
const PixValidator = require('./utils/pix-validator');
const LoteIntegrityValidator = require('./utils/lote-integrity-validator');
const WebhookSignatureValidator = require('./utils/webhook-signature-validator');

require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 8080;

// =====================================================
// INST√ÇNCIAS DOS VALIDADORES
// =====================================================

const pixValidator = new PixValidator();
const loteIntegrityValidator = new LoteIntegrityValidator();
const webhookSignatureValidator = new WebhookSignatureValidator();

// =====================================================
// CONFIGURA√á√ÉO SUPABASE UNIFICADA
// =====================================================

const { 
  supabaseAdmin, 
  validateSupabaseCredentials, 
  testSupabaseConnection, 
  supabaseHealthCheck 
} = require('./database/supabase-unified-config');

// Importar servi√ßo de email
const emailService = require('./services/emailService');

// =====================================================
// SISTEMAS DE MONITORAMENTO AVAN√áADOS
// =====================================================

const {
  startCustomMetricsCollection,
  stopCustomMetricsCollection,
  getCustomMetricsStats,
  generateCustomMetricsReport,
  testCustomMetrics
} = require('./monitoring/flyio-custom-metrics');

const {
  startNotificationSystem,
  stopNotificationSystem,
  sendNotification,
  getNotificationStats,
  generateNotificationReport,
  testNotifications
} = require('./monitoring/flyio-advanced-notifications');

const {
  startConfigBackupSystem,
  stopConfigBackupSystem,
  executeManualBackup,
  getBackupStats,
  generateBackupReport,
  testConfigBackup
} = require('./monitoring/flyio-config-backup');

let supabase = supabaseAdmin;
let dbConnected = false;

// Conectar Supabase com valida√ß√£o
async function connectSupabase() {
  try {
    console.log('üîç [SUPABASE] Validando credenciais...');
    
    // Validar credenciais
    const validation = validateSupabaseCredentials();
    if (!validation.valid) {
      console.error('‚ùå [SUPABASE] Credenciais inv√°lidas:', validation.errors);
      dbConnected = false;
      return false;
    }
    
    console.log('‚úÖ [SUPABASE] Credenciais validadas');
    
    // Testar conex√£o
    const connectionTest = await testSupabaseConnection();
    if (!connectionTest.success) {
      console.error('‚ùå [SUPABASE] Falha na conex√£o:', connectionTest.error);
      dbConnected = false;
      return false;
    }
    
    console.log('‚úÖ [SUPABASE] Conectado com sucesso');
    dbConnected = true;
    return true;
    
  } catch (error) {
    console.log('‚ùå [SUPABASE] Erro na conex√£o:', error.message);
    dbConnected = false;
    return false;
  }
}

// =====================================================
// CONFIGURA√á√ÉO MERCADO PAGO
// =====================================================

const mercadoPagoAccessToken = process.env.MERCADOPAGO_ACCESS_TOKEN;
let mercadoPagoConnected = false;

// Testar Mercado Pago
async function testMercadoPago() {
  if (!mercadoPagoAccessToken) {
    console.log('‚ö†Ô∏è [MERCADO-PAGO] Token n√£o configurado');
    return false;
  }

  try {
    const response = await axios.get('https://api.mercadopago.com/v1/payment_methods', {
      headers: { 
        'Authorization': `Bearer ${mercadoPagoAccessToken}`,
        'Accept': 'application/json',
        'User-Agent': 'GolDeOuro/1.2.0'
      },
      timeout: 5000,
      maxRedirects: 3,
      validateStatus: (status) => status < 500
    });
    
    if (response.status === 200) {
      console.log('‚úÖ [MERCADO-PAGO] Conectado com sucesso');
      mercadoPagoConnected = true;
      return true;
    }
  } catch (error) {
    console.log('‚ùå [MERCADO-PAGO] Erro:', error.message);
    mercadoPagoConnected = false;
    return false;
  }
}

// =====================================================
// MIDDLEWARE E CONFIGURA√á√ïES
// =====================================================

// Middleware de seguran√ßa
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));

app.use(compression());
app.set('trust proxy', true);

// CORS configurado
app.use(cors({
  origin: [
    'https://goldeouro.lol',
    'https://www.goldeouro.lol',
    'https://admin.goldeouro.lol'
  ],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// Rate limiting melhorado
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // m√°ximo 100 requests por IP (mais razo√°vel)
  message: {
    success: false,
    message: 'Muitas tentativas. Tente novamente em 15 minutos.'
  },
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => {
    // Pular rate limiting para health check, meta e auth
    return req.path === '/health' || 
           req.path === '/meta' || 
           req.path.startsWith('/auth/') ||
           req.path.startsWith('/api/auth/');
  },
  handler: (req, res) => {
    console.log(`üö´ [RATE-LIMIT] IP ${req.ip} bloqueado por excesso de requests (${req.path})`);
    res.status(429).json({
      success: false,
      message: 'Muitas tentativas. Tente novamente em 15 minutos.',
      retryAfter: Math.round(15 * 60) // 15 minutos em segundos
    });
  }
});

// Rate limiting espec√≠fico para autentica√ß√£o
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 5, // m√°ximo 5 tentativas de login por IP
  message: {
        success: false,
    message: 'Muitas tentativas de login. Tente novamente em 15 minutos.'
  },
  skipSuccessfulRequests: true, // N√£o contar tentativas bem-sucedidas
  handler: (req, res) => {
    console.log(`üö´ [AUTH-LIMIT] IP ${req.ip} bloqueado por excesso de tentativas de login`);
    res.status(429).json({
      success: false,
      message: 'Muitas tentativas de login. Tente novamente em 15 minutos.'
    });
  }
});

app.use(limiter); // Rate limiting global
app.use('/api/', limiter);
app.use('/api/auth/', authLimiter);

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));


// =====================================================
// MIDDLEWARE DE AUTENTICA√á√ÉO
// =====================================================

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    console.log('‚ùå [AUTH] Token n√£o fornecido');
        return res.status(401).json({
          success: false,
      message: 'Token de acesso requerido' 
    });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) {
      console.log('‚ùå [AUTH] Token inv√°lido:', err.message);
        return res.status(403).json({
          success: false,
        message: 'Token inv√°lido' 
        });
      }
    req.user = user;
      next();
  });
};

// =====================================================
// SISTEMA DE LOTES CORRIGIDO
// =====================================================

let lotesAtivos = new Map();
// Vari√°veis globais para m√©tricas - ZERADAS para produ√ß√£o real
let contadorChutesGlobal = 0; // Zerado - sem dados simulados
let ultimoGolDeOuro = 0; // Zerado - sem dados simulados

// Configura√ß√µes dos lotes por valor de aposta
const batchConfigs = {
  1: { size: 10, totalValue: 10, winChance: 0.1, description: "10% chance" },
  2: { size: 5, totalValue: 10, winChance: 0.2, description: "20% chance" },
  5: { size: 2, totalValue: 10, winChance: 0.5, description: "50% chance" },
  10: { size: 1, totalValue: 10, winChance: 1.0, description: "100% chance" }
};

// Fun√ß√£o para obter ou criar lote por valor de aposta
function getOrCreateLoteByValue(amount) {
  const config = batchConfigs[amount];
  if (!config) {
    throw new Error(`Valor de aposta inv√°lido: ${amount}`);
  }

  // Verificar se existe lote ativo para este valor
  let loteAtivo = null;
  for (const [loteId, lote] of lotesAtivos.entries()) {
    if (lote.valorAposta === amount && lote.status === 'active' && lote.chutes.length < config.size) {
      loteAtivo = lote;
      break;
    }
  }

  // Se n√£o existe lote ativo, criar novo
  if (!loteAtivo) {
    const loteId = `lote_${amount}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    loteAtivo = {
      id: loteId,
      valorAposta: amount,
      config: config,
      chutes: [],
      status: 'active',
      winnerIndex: Math.floor(Math.random() * config.size), // CORRIGIDO: Aleat√≥rio por lote
      createdAt: new Date().toISOString(),
      totalArrecadado: 0,
      premioTotal: 0
    };
    lotesAtivos.set(loteId, loteAtivo);
    console.log(`üéÆ [LOTE] Novo lote criado: ${loteId} (R$${amount})`);
  }

  return loteAtivo;
}

// =====================================================
// ROTAS DE AUTENTICA√á√ÉO
// =====================================================

// Recupera√ß√£o de senha - GERAR TOKEN
app.post('/api/auth/forgot-password', [
  body('email').isEmail().normalizeEmail()
], validateData, async (req, res) => {
  try {
    const { email } = req.body;

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    // Verificar se email existe
    const { data: user, error: userError } = await supabase
      .from('usuarios')
      .select('id, email, username')
      .eq('email', email)
      .eq('ativo', true)
      .single();

    if (userError || !user) {
      // Por seguran√ßa, sempre retornar sucesso mesmo se email n√£o existir
      console.log(`üìß [FORGOT-PASSWORD] Email n√£o encontrado: ${email}`);
      return res.status(200).json({
        success: true,
        message: 'Se o email existir, voc√™ receber√° um link de recupera√ß√£o'
      });
    }

    // Gerar token de recupera√ß√£o (v√°lido por 1 hora)
    const resetToken = jwt.sign(
      { 
        userId: user.id, 
        email: user.email, 
        type: 'password_reset' 
      },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );

    // Salvar token no banco de dados
    const { error: tokenError } = await supabase
      .from('password_reset_tokens')
      .insert({
        user_id: user.id,
        token: resetToken,
        expires_at: new Date(Date.now() + 60 * 60 * 1000).toISOString(), // 1 hora
        used: false,
        created_at: new Date().toISOString()
      });

    if (tokenError) {
      console.error('‚ùå [FORGOT-PASSWORD] Erro ao salvar token:', tokenError);
      return res.status(500).json({
        success: false,
        message: 'Erro interno do servidor'
      });
    }

    // Enviar email real com link de recupera√ß√£o
    const emailResult = await emailService.sendPasswordResetEmail(email, user.username, resetToken);
    
    if (emailResult.success) {
      console.log(`üìß [FORGOT-PASSWORD] Email enviado para ${email}:`, emailResult.messageId);
    } else {
      console.log(`‚ö†Ô∏è [FORGOT-PASSWORD] Falha ao enviar email para ${email}:`, emailResult.error);
      // Logar token como fallback
      console.log(`üîó [FORGOT-PASSWORD] Link de recupera√ß√£o: https://goldeouro.lol/reset-password?token=${resetToken}`);
    }

    console.log(`‚úÖ [FORGOT-PASSWORD] Token de recupera√ß√£o gerado para: ${email}`);
    
    res.status(200).json({
      success: true,
      message: 'Se o email existir, voc√™ receber√° um link de recupera√ß√£o'
    });

  } catch (error) {
    console.error('‚ùå [FORGOT-PASSWORD] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Reset de senha - VALIDAR TOKEN E ALTERAR SENHA
app.post('/api/auth/reset-password', [
  body('token').notEmpty(),
  body('newPassword').isLength({ min: 6 })
], validateData, async (req, res) => {
  try {
    const { token, newPassword } = req.body;

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    // Verificar se token existe e √© v√°lido
    const { data: tokenData, error: tokenError } = await supabase
      .from('password_reset_tokens')
      .select('user_id, expires_at, used')
      .eq('token', token)
      .eq('used', false)
      .single();

    if (tokenError || !tokenData) {
      return res.status(400).json({
        success: false,
        message: 'Token inv√°lido ou expirado'
      });
    }

    // Verificar se token n√£o expirou
    if (new Date() > new Date(tokenData.expires_at)) {
      return res.status(400).json({
        success: false,
        message: 'Token expirado'
      });
    }

    // Hash da nova senha
    const saltRounds = 10;
    const newPasswordHash = await bcrypt.hash(newPassword, saltRounds);

    // Atualizar senha do usu√°rio
    const { error: updateError } = await supabase
      .from('usuarios')
      .update({ 
        senha_hash: newPasswordHash,
        updated_at: new Date().toISOString()
      })
      .eq('id', tokenData.user_id);

    if (updateError) {
      console.error('‚ùå [RESET-PASSWORD] Erro ao atualizar senha:', updateError);
      return res.status(500).json({
        success: false,
        message: 'Erro ao atualizar senha'
      });
    }

    // Marcar token como usado
    const { error: markUsedError } = await supabase
      .from('password_reset_tokens')
      .update({ used: true })
      .eq('token', token);

    if (markUsedError) {
      console.error('‚ùå [RESET-PASSWORD] Erro ao marcar token como usado:', markUsedError);
    }

    console.log(`‚úÖ [RESET-PASSWORD] Senha alterada com sucesso para usu√°rio ${tokenData.user_id}`);
    
    res.status(200).json({
      success: true,
      message: 'Senha alterada com sucesso'
    });

  } catch (error) {
    console.error('‚ùå [RESET-PASSWORD] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Verifica√ß√£o de email
app.post('/api/auth/verify-email', [
  body('token').notEmpty()
], validateData, async (req, res) => {
  try {
    const { token } = req.body;

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    // Verificar se token existe e √© v√°lido
    const { data: tokenData, error: tokenError } = await supabase
      .from('email_verification_tokens')
      .select('user_id, expires_at, used')
      .eq('token', token)
      .eq('used', false)
      .single();

    if (tokenError || !tokenData) {
      return res.status(400).json({
        success: false,
        message: 'Token de verifica√ß√£o inv√°lido ou expirado'
      });
    }

    // Verificar se token n√£o expirou
    if (new Date() > new Date(tokenData.expires_at)) {
      return res.status(400).json({
        success: false,
        message: 'Token de verifica√ß√£o expirado'
      });
    }

    // Marcar email como verificado
    const { error: updateError } = await supabase
      .from('usuarios')
      .update({ 
        email_verificado: true,
        updated_at: new Date().toISOString()
      })
      .eq('id', tokenData.user_id);

    if (updateError) {
      console.error('‚ùå [VERIFY-EMAIL] Erro ao verificar email:', updateError);
      return res.status(500).json({
        success: false,
        message: 'Erro ao verificar email'
      });
    }

    // Marcar token como usado
    const { error: markUsedError } = await supabase
      .from('email_verification_tokens')
      .update({ used: true })
      .eq('token', token);

    if (markUsedError) {
      console.error('‚ùå [VERIFY-EMAIL] Erro ao marcar token como usado:', markUsedError);
    }

    console.log(`‚úÖ [VERIFY-EMAIL] Email verificado com sucesso para usu√°rio ${tokenData.user_id}`);
    
    res.status(200).json({
      success: true,
      message: 'Email verificado com sucesso! Sua conta est√° ativa.'
    });

  } catch (error) {
    console.error('‚ùå [VERIFY-EMAIL] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Registro de usu√°rio
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, username } = req.body;

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel' 
      });
    }

    // Verificar se email j√° existe
      const { data: existingUser, error: checkError } = await supabase
        .from('usuarios')
        .select('id')
        .eq('email', email)
        .single();

    if (checkError && checkError.code !== 'PGRST116') {
      console.error('‚ùå [REGISTER] Erro ao verificar email:', checkError);
      return res.status(500).json({ 
          success: false,
        message: 'Erro interno do servidor' 
      });
    }

    if (existingUser) {
      console.log(`‚ö†Ô∏è [REGISTER] Tentativa de registro com email existente: ${email}`);
      
      // Tentar fazer login automaticamente se email j√° existe
      try {
        const { data: user, error: userError } = await supabase
        .from('usuarios')
          .select('*')
          .eq('email', email)
          .eq('ativo', true)
        .single();

        if (!userError && user) {
          // Verificar senha
          const senhaValida = await bcrypt.compare(password, user.senha_hash);
          if (senhaValida) {
      // Gerar token JWT
      const token = jwt.sign(
              { 
                userId: user.id, 
                email: user.email,
                username: user.username
              },
              process.env.JWT_SECRET,
        { expiresIn: '24h' }
      );

            console.log(`‚úÖ [REGISTER] Login autom√°tico realizado para email existente: ${email}`);

            return res.status(200).json({
        success: true,
              message: 'Login realizado automaticamente (email j√° cadastrado)',
              token: token,
        user: {
                id: user.id,
                email: user.email,
                username: user.username,
                saldo: user.saldo,
                tipo: user.tipo,
                total_apostas: user.total_apostas,
                total_ganhos: user.total_ganhos
              }
            });
          }
        }
      } catch (loginError) {
        console.log('‚ö†Ô∏è [REGISTER] Erro no login autom√°tico:', loginError.message);
      }
      
      return res.status(400).json({
        success: false,
        message: 'Email j√° cadastrado. Use a op√ß√£o "Esqueci minha senha" se necess√°rio.' 
      });
    }

    // Hash da senha
    const saltRounds = 10;
    const senhaHash = await bcrypt.hash(password, saltRounds);
    
    // Criar usu√°rio de teste para an√°lise de aprendizado
    if (email === 'teste-aprendizado@example.com') {
      console.log('üß™ [TEST] Criando usu√°rio de teste para an√°lise de aprendizado');
    }

    // Criar usu√°rio com saldo inicial para testes
    const { data: newUser, error: insertError } = await supabase
        .from('usuarios')
      .insert({
        email: email,
        username: username,
        senha_hash: senhaHash,
        saldo: calculateInitialBalance('regular'), // Saldo inicial din√¢mico
        tipo: 'jogador',
        ativo: true,
        email_verificado: false,
        total_apostas: 0,
        total_ganhos: 0.00
      })
      .select()
        .single();

    if (insertError) {
      console.error('‚ùå [REGISTER] Erro ao criar usu√°rio:', insertError);
      return res.status(500).json({ 
          success: false,
        message: 'Erro ao criar usu√°rio' 
        });
      }

      // Gerar token JWT
      const token = jwt.sign(
      { 
        userId: newUser.id, 
        email: newUser.email,
        username: newUser.username
      },
      process.env.JWT_SECRET,
        { expiresIn: '24h' }
      );

    console.log(`‚úÖ [REGISTER] Usu√°rio criado: ${email} com saldo inicial de R$ ${calculateInitialBalance('regular')}`);

    res.status(201).json({
        success: true,
      message: 'Usu√°rio criado com sucesso',
      token: token,
        user: {
        id: newUser.id,
        email: newUser.email,
        username: newUser.username,
        saldo: newUser.saldo,
        tipo: newUser.tipo
      }
    });

  } catch (error) {
    console.error('‚ùå [REGISTER] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor' 
    });
  }
});

// Login de usu√°rio
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    // Buscar usu√°rio
    const { data: user, error: userError } = await supabase
      .from('usuarios')
      .select('*')
      .eq('email', email)
      .eq('ativo', true)
      .single();

    if (userError || !user) {
      console.log(`‚ùå [LOGIN] Usu√°rio n√£o encontrado: ${email}`);
      return res.status(401).json({
        success: false,
        message: 'Credenciais inv√°lidas'
      });
    }

    // Verificar senha
    const senhaValida = await bcrypt.compare(password, user.senha_hash);
    if (!senhaValida) {
      console.log(`‚ùå [LOGIN] Senha inv√°lida para: ${email}`);
      return res.status(401).json({
        success: false,
        message: 'Credenciais inv√°lidas'
      });
    }

    // Verificar se usu√°rio precisa de saldo inicial (para usu√°rios antigos)
    if (user.saldo === 0 || user.saldo === null) {
      try {
        const { error: updateError } = await supabase
          .from('usuarios')
          .update({ saldo: calculateInitialBalance('regular') })
          .eq('id', user.id);
        
        if (!updateError) {
          user.saldo = calculateInitialBalance('regular');
          console.log(`üí∞ [LOGIN] Saldo inicial de R$ ${calculateInitialBalance('regular')} adicionado para usu√°rio ${email}`);
        }
      } catch (saldoError) {
        console.log('‚ö†Ô∏è [LOGIN] Erro ao adicionar saldo inicial:', saldoError.message);
      }
    }

    // Gerar token JWT
    const token = jwt.sign(
      { 
        userId: user.id, 
        email: user.email,
        username: user.username
      },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );

    console.log(`‚úÖ [LOGIN] Login realizado: ${email}`);

    res.json({
      success: true,
      message: 'Login realizado com sucesso',
      token: token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        saldo: user.saldo,
        tipo: user.tipo,
        total_apostas: user.total_apostas,
        total_ganhos: user.total_ganhos
      }
    });

  } catch (error) {
    console.error('‚ùå [LOGIN] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// =====================================================
// ROTAS DE PERFIL DO USU√ÅRIO
// =====================================================

// Obter perfil do usu√°rio
app.get('/api/user/profile', authenticateToken, async (req, res) => {
  try {
    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    const { data: user, error: userError } = await supabase
      .from('usuarios')
      .select('*')
      .eq('id', req.user.userId)
      .single();

    if (userError || !user) {
      console.error('‚ùå [PROFILE] Usu√°rio n√£o encontrado:', userError);
      return res.status(404).json({ 
        success: false,
        message: 'Usu√°rio n√£o encontrado' 
      });
    }

    res.json({
      success: true,
      data: {
        id: user.id,
        email: user.email,
        username: user.username,
        nome: user.username, // Compatibilidade com frontend
        saldo: user.saldo,
        tipo: user.tipo,
        total_apostas: user.total_apostas,
        total_ganhos: user.total_ganhos,
        created_at: user.created_at,
        updated_at: user.updated_at
      }
    });

  } catch (error) {
    console.error('‚ùå [PROFILE] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Atualizar perfil do usu√°rio
app.put('/api/user/profile', authenticateToken, async (req, res) => {
  try {
    const { nome, email } = req.body;
    
    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    // Validar dados
    if (!nome || !email) {
      return res.status(400).json({ 
        success: false,
        message: 'Nome e email s√£o obrigat√≥rios' 
      });
    }

    // Verificar se email j√° existe (exceto para o usu√°rio atual)
    const { data: existingUser, error: checkError } = await supabase
      .from('usuarios')
      .select('id')
      .eq('email', email)
      .neq('id', req.user.userId)
      .single();

    if (checkError && checkError.code !== 'PGRST116') {
      console.error('‚ùå [PROFILE] Erro ao verificar email:', checkError);
      return res.status(500).json({ 
      success: false,
      message: 'Erro interno do servidor'
    });
  }

    if (existingUser) {
      return res.status(400).json({ 
        success: false,
        message: 'Este email j√° est√° em uso por outro usu√°rio' 
      });
    }

    // Atualizar usu√°rio
    const { data: updatedUser, error: updateError } = await supabase
      .from('usuarios')
      .update({
        username: nome,
        email: email,
        updated_at: new Date().toISOString()
      })
      .eq('id', req.user.userId)
      .select()
      .single();

    if (updateError) {
      console.error('‚ùå [PROFILE] Erro ao atualizar usu√°rio:', updateError);
      return res.status(500).json({
        success: false,
        message: 'Erro ao atualizar perfil' 
      });
    }

    console.log(`‚úÖ [PROFILE] Perfil atualizado para usu√°rio ${req.user.userId}`);

    res.json({
      success: true,
      message: 'Perfil atualizado com sucesso!',
      data: {
        id: updatedUser.id,
        email: updatedUser.email,
        username: updatedUser.username,
        nome: updatedUser.username, // Compatibilidade
        saldo: updatedUser.saldo || 0,
        total_apostas: updatedUser.total_apostas || 0,
        total_ganhos: updatedUser.total_ganhos || 0,
        tipo: updatedUser.tipo || 'user',
        created_at: updatedUser.created_at,
        updated_at: updatedUser.updated_at
      }
    });
  } catch (error) {
    console.error('‚ùå [PROFILE] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// =====================================================
// SISTEMA DE JOGO CORRIGIDO
// =====================================================

// Endpoint para chutar
app.post('/api/games/shoot', authenticateToken, async (req, res) => {
  try {
    const { direction, amount } = req.body;
    
    // Validar entrada
    if (!direction || !amount) {
      return res.status(400).json({
        success: false,
        message: 'Dire√ß√£o e valor s√£o obrigat√≥rios'
      });
    }

    // Validar valor de aposta
    if (!batchConfigs[amount]) {
      return res.status(400).json({
        success: false,
        message: 'Valor de aposta inv√°lido. Use: 1, 2, 5 ou 10'
      });
    }

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    // Verificar saldo do usu√°rio
    const { data: user, error: userError } = await supabase
      .from('usuarios')
      .select('saldo')
      .eq('id', req.user.userId)
      .single();

    if (userError || !user) {
      return res.status(404).json({
        success: false,
        message: 'Usu√°rio n√£o encontrado'
      });
    }

    if (user.saldo < amount) {
      return res.status(400).json({
      success: false,
        message: 'Saldo insuficiente'
      });
    }

    // Obter ou criar lote para este valor
    const lote = getOrCreateLoteByValue(amount);
    
    // Validar integridade do lote antes de processar chute
    const integrityValidation = loteIntegrityValidator.validateBeforeShot(lote, {
      direction: direction,
      amount: amount,
      userId: req.user.userId
    });

    if (!integrityValidation.valid) {
      console.error('‚ùå [SHOOT] Problema de integridade do lote:', integrityValidation.error);
      return res.status(400).json({
        success: false,
        message: integrityValidation.error
      });
    }
    
    // Incrementar contador global
    contadorChutesGlobal++;
    
    // Verificar se √© Gol de Ouro (a cada 1000 chutes)
    const isGolDeOuro = contadorChutesGlobal % 1000 === 0;
    
    // Salvar contador no Supabase
    await saveGlobalCounter();
    
    // Determinar se √© gol baseado no sistema de lotes
    const shotIndex = lote.chutes.length;
    const isGoal = shotIndex === lote.winnerIndex;
    const result = isGoal ? 'goal' : 'miss';
    
    let premio = 0;
    let premioGolDeOuro = 0;
    
    if (isGoal) {
      // Pr√™mio normal: R$5 fixo (independente do valor apostado)
      premio = 5.00;
      
      // Gol de Ouro: R$100 adicional
      if (isGolDeOuro) {
        premioGolDeOuro = 100.00;
        ultimoGolDeOuro = contadorChutesGlobal;
        console.log(`üèÜ [GOL DE OURO] Chute #${contadorChutesGlobal} - Pr√™mio: R$ ${premioGolDeOuro}`);
      }
    }
    
    // Adicionar chute ao lote
    const chute = {
      id: `${lote.id}_${shotIndex}`,
      playerId: req.user.userId,
      direction,
      amount,
      result,
      premio,
      premioGolDeOuro,
      isGolDeOuro,
      shotIndex: shotIndex + 1,
      timestamp: new Date().toISOString()
    };
    
    lote.chutes.push(chute);
    lote.totalArrecadado += amount;
    lote.premioTotal += premio + premioGolDeOuro;

    // Validar integridade do lote ap√≥s adicionar chute
    const postShotValidation = loteIntegrityValidator.validateAfterShot(lote, {
      result: result,
      premio: premio,
      premioGolDeOuro: premioGolDeOuro,
      timestamp: new Date().toISOString()
    });

    if (!postShotValidation.valid) {
      console.error('‚ùå [SHOOT] Problema de integridade ap√≥s chute:', postShotValidation.error);
      // Reverter chute do lote
      lote.chutes.pop();
      lote.totalArrecadado -= amount;
      lote.premioTotal -= premio + premioGolDeOuro;
      return res.status(400).json({
        success: false,
        message: postShotValidation.error
      });
    }

    // Salvar chute no banco de dados
    const { error: chuteError } = await supabase
      .from('chutes')
      .insert({
        usuario_id: req.user.userId,
        lote_id: lote.id,
        direcao: direction,
        valor_aposta: amount,
        resultado: result,
        premio: premio,
        premio_gol_de_ouro: premioGolDeOuro,
        is_gol_de_ouro: isGolDeOuro,
        contador_global: contadorChutesGlobal,
        shot_index: shotIndex + 1
      });

    if (chuteError) {
      console.error('‚ùå [SHOOT] Erro ao salvar chute:', chuteError);
    }

    // Verificar se lote est√° completo
    if (lote.chutes.length >= lote.config.size) {
      lote.status = 'completed';
      console.log(`üèÜ [LOTE] Lote ${lote.id} completado: ${lote.chutes.length} chutes, R$${lote.totalArrecadado} arrecadado, R$${lote.premioTotal} em pr√™mios`);
    }
    
    const shootResult = {
      loteId: lote.id,
      direction,
      amount,
      result,
      premio,
      premioGolDeOuro,
      isGolDeOuro,
      contadorGlobal: contadorChutesGlobal,
      timestamp: new Date().toISOString(),
      playerId: req.user.userId,
      loteProgress: {
        current: lote.chutes.length,
        total: lote.config.size,
        remaining: lote.config.size - lote.chutes.length
      },
      isLoteComplete: lote.status === 'completed',
      novoSaldo: user.saldo - amount + premio + premioGolDeOuro
    };

    // Atualizar saldo do usu√°rio
    const novoSaldo = user.saldo - amount + premio + premioGolDeOuro;
    const { error: saldoError } = await supabase
      .from('usuarios')
      .update({ saldo: novoSaldo })
      .eq('id', req.user.userId);

    if (saldoError) {
      console.error('‚ùå [SHOOT] Erro ao atualizar saldo:', saldoError);
    }
    
    console.log(`‚öΩ [SHOOT] Chute #${contadorChutesGlobal}: ${result} por usu√°rio ${req.user.userId}`);
    
    res.status(200).json({
      success: true,
      data: shootResult
    });

  } catch (error) {
    console.error('‚ùå [SHOOT] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// =====================================================
// SISTEMA DE SAQUES PIX COM VALIDA√á√ÉO
// =====================================================

// Solicitar saque PIX
app.post('/api/withdraw/request', authenticateToken, async (req, res) => {
  try {
    const { valor, chave_pix, tipo_chave } = req.body;
    const userId = req.user.userId;

    // Validar dados de entrada usando PixValidator
    const withdrawData = {
      amount: valor,
      pixKey: chave_pix,
      pixType: tipo_chave,
      userId: userId
    };

    const validation = await pixValidator.validateWithdrawData(withdrawData);
    if (!validation.valid) {
      return res.status(400).json({
        success: false,
        message: validation.error
      });
    }

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    // Verificar saldo do usu√°rio
    const { data: usuario, error: userError } = await supabase
      .from('usuarios')
      .select('saldo')
      .eq('id', userId)
      .single();

    if (userError || !usuario) {
      return res.status(404).json({
        success: false,
        message: 'Usu√°rio n√£o encontrado'
      });
    }

    if (parseFloat(usuario.saldo) < parseFloat(valor)) {
      return res.status(400).json({
        success: false,
        message: 'Saldo insuficiente'
      });
    }

    // Calcular taxa de saque
    const taxa = parseFloat(process.env.PAGAMENTO_TAXA_SAQUE || '2.00');
    const valorLiquido = parseFloat(valor) - taxa;

    // Criar saque no banco
    const { data: saque, error: saqueError } = await supabase
      .from('saques')
      .insert({
        usuario_id: userId,
        valor: parseFloat(valor),
        valor_liquido: valorLiquido,
        taxa: taxa,
        chave_pix: validation.data.pixKey,
        tipo_chave: validation.data.pixType,
        status: 'pendente',
        created_at: new Date().toISOString()
      })
      .select()
      .single();

    if (saqueError) {
      console.error('‚ùå [SAQUE] Erro ao criar saque:', saqueError);
      return res.status(500).json({
        success: false,
        message: 'Erro ao criar saque'
      });
    }

    // Criar transa√ß√£o de d√©bito
    const { error: transacaoError } = await supabase
      .from('transacoes')
      .insert({
        usuario_id: userId,
        tipo: 'debito',
        valor: parseFloat(valor),
        descricao: `Saque PIX - ${validation.data.pixType}`,
        status: 'processando',
        referencia_id: saque.id,
        created_at: new Date().toISOString()
      });

    if (transacaoError) {
      console.error('‚ùå [SAQUE] Erro ao criar transa√ß√£o:', transacaoError);
    }

    console.log(`üí∞ [SAQUE] Saque solicitado: R$ ${valor} para usu√°rio ${userId}`);

    res.status(201).json({
      success: true,
      message: 'Saque solicitado com sucesso',
      data: {
        id: saque.id,
        valor: valor,
        valor_liquido: valorLiquido,
        taxa: taxa,
        chave_pix: validation.data.pixKey,
        tipo_chave: validation.data.pixType,
        status: 'pendente',
        created_at: saque.created_at
      }
    });

  } catch (error) {
    console.error('‚ùå [SAQUE] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Buscar saques do usu√°rio
app.get('/api/withdraw/history', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel'
      });
    }

    const { data: saques, error: saquesError } = await supabase
      .from('saques')
      .select('*')
      .eq('usuario_id', userId)
      .order('created_at', { ascending: false })
      .limit(50);

    if (saquesError) {
      console.error('‚ùå [SAQUE] Erro ao buscar saques:', saquesError);
      return res.status(500).json({
        success: false,
        message: 'Erro ao buscar hist√≥rico de saques'
      });
    }

    res.json({
      success: true,
      data: {
        saques: saques || [],
        total: saques?.length || 0
      }
    });

  } catch (error) {
    console.error('‚ùå [SAQUE] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// =====================================================
// SISTEMA DE PAGAMENTOS PIX CORRIGIDO
// =====================================================

// Criar pagamento PIX
app.post('/api/payments/pix/criar', authenticateToken, async (req, res) => {
  try {
    const { amount } = req.body;
    
    if (!amount || amount < 1) {
      return res.status(400).json({
        success: false,
        message: 'Valor inv√°lido'
      });
    }

    if (amount > 1000) {
      return res.status(400).json({
        success: false,
        message: 'Valor m√°ximo: R$ 1.000,00'
      });
    }

    // APENAS MERCADO PAGO REAL - SEM FALLBACK
    if (!mercadoPagoConnected) {
      return res.status(503).json({
        success: false,
        message: 'Sistema de pagamento temporariamente indispon√≠vel. Tente novamente em alguns minutos.'
      });
    }

    try {
      // Buscar dados completos do usu√°rio
      const { data: userData, error: userDataError } = await supabase
        .from('usuarios')
        .select('email, username')
        .eq('id', req.user.userId)
        .single();

      const userName = userData?.username || '';
      const userEmail = userData?.email || req.user.email;

      // Preparar nome do comprador
      const names = userName.split(' ');
      const firstName = names[0] || '';
      const lastName = names.slice(1).join(' ') || '';

      const paymentData = {
        transaction_amount: parseFloat(amount),
        description: 'Dep√≥sito Gol de Ouro',
        payment_method_id: 'pix',
        payer: {
          email: userEmail,
          first_name: firstName,
          last_name: lastName,
          identification: {
            type: 'CPF',
            number: '00000000000' // Campo obrigat√≥rio, usar valor tempor√°rio
          }
        },
        external_reference: `goldeouro_${req.user.userId}_${Date.now()}`,
        items: [{
          id: 'deposito',
          title: 'Dep√≥sito Gol de Ouro',
          description: 'Recarga de saldo para o jogo',
          category_id: 'digital',
          quantity: 1,
          unit_price: parseFloat(amount)
        }],
        statement_descriptor: 'GOL DE OURO',
        notification_url: `${process.env.BACKEND_URL || 'https://goldeouro-backend-v2.fly.dev'}/api/payments/webhook`
      };

      // Gerar X-Idempotency-Key √∫nico
      const idempotencyKey = `pix_${req.user.userId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      const response = await axios.post(
        'https://api.mercadopago.com/v1/payments',
        paymentData,
        {
          headers: {
            'Authorization': `Bearer ${process.env.MERCADOPAGO_ACCESS_TOKEN}`,
            'Content-Type': 'application/json',
            'X-Idempotency-Key': idempotencyKey,
            'Accept': 'application/json',
            'User-Agent': 'GolDeOuro/1.2.0'
          },
          timeout: 8000,
          maxRedirects: 3,
          validateStatus: (status) => status < 500
        }
      );

      const payment = response.data;
      
      // Salvar no banco de dados
      if (dbConnected && supabase) {
        const { data: pixRecord, error: insertError } = await supabase
          .from('pagamentos_pix')
          .insert({
            usuario_id: req.user.userId,
            external_id: payment.id.toString(),
            payment_id: payment.id.toString(),
            amount: parseFloat(amount),
            status: 'pending',
            qr_code: payment.point_of_interaction?.transaction_data?.qr_code || null,
            qr_code_base64: payment.point_of_interaction?.transaction_data?.qr_code_base64 || null,
            pix_copy_paste: payment.point_of_interaction?.transaction_data?.qr_code || null
          })
          .select()
          .single();

        if (insertError) {
          console.error('‚ùå [PIX] Erro ao salvar no banco:', insertError);
        }
      }

      console.log(`üí∞ [PIX] PIX real criado: R$ ${amount} para usu√°rio ${req.user.userId}`);

      res.json({
        success: true,
        message: 'PIX criado com sucesso!',
        data: {
          id: payment.id,
          amount: parseFloat(amount),
          qr_code: payment.point_of_interaction?.transaction_data?.qr_code,
          qr_code_base64: payment.point_of_interaction?.transaction_data?.qr_code_base64,
          pix_copy_paste: payment.point_of_interaction?.transaction_data?.qr_code,
          pix_code: payment.point_of_interaction?.transaction_data?.qr_code,
          status: 'pending',
          created_at: new Date().toISOString()
        }
      });

    } catch (mpError) {
      console.error('‚ùå [PIX] Erro Mercado Pago:', mpError.response?.data || mpError.message);
      return res.status(500).json({
        success: false,
        message: 'Erro ao criar PIX. Tente novamente em alguns minutos.'
      });
    }

  } catch (error) {
    console.error('‚ùå [PIX] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Buscar pagamentos PIX do usu√°rio
app.get('/api/payments/pix/usuario', authenticateToken, async (req, res) => {
  try {
    console.log(`üîç [PIX] Buscando pagamentos para usu√°rio: ${req.user.userId}`);
    
    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      console.log('‚ùå [PIX] Supabase n√£o conectado');
      return res.status(503).json({ 
        success: false,
        message: 'Sistema temporariamente indispon√≠vel' 
      });
    }

    // Primeiro, verificar se a tabela existe tentando uma query simples
    const { data: testData, error: testError } = await supabase
      .from('pagamentos_pix')
      .select('id')
      .limit(1);

    if (testError) {
      console.error('‚ùå [PIX] Erro ao acessar tabela pagamentos_pix:', testError);
      console.error('‚ùå [PIX] Detalhes do erro:', {
        message: testError.message,
        details: testError.details,
        hint: testError.hint,
        code: testError.code
      });
      
      // Retornar lista vazia se a tabela n√£o existir
      return res.json({
        success: true,
        data: {
          payments: [],
          total: 0,
          message: 'Nenhum pagamento encontrado'
        }
      });
    }

    // Buscar pagamentos do usu√°rio
    const { data: payments, error: paymentsError } = await supabase
                .from('pagamentos_pix')
                .select('*')
      .eq('user_id', req.user.userId)
      .order('created_at', { ascending: false })
      .limit(50);

    if (paymentsError) {
      console.error('‚ùå [PIX] Erro ao buscar pagamentos do usu√°rio:', paymentsError);
      console.error('‚ùå [PIX] Detalhes do erro:', {
        message: paymentsError.message,
        details: paymentsError.details,
        hint: paymentsError.hint,
        code: paymentsError.code
      });
      
      // Retornar lista vazia em caso de erro
      return res.json({
        success: true,
        data: {
          payments: [],
          total: 0,
          message: 'Erro ao carregar pagamentos'
        }
      });
    }

    console.log(`‚úÖ [PIX] ${payments?.length || 0} pagamentos encontrados para usu√°rio ${req.user.userId}`);

    res.json({
      success: true,
      data: {
        payments: payments || [],
        total: payments?.length || 0
      }
    });

  } catch (error) {
    console.error('‚ùå [PIX] Erro geral:', error);
    console.error('‚ùå [PIX] Stack trace:', error.stack);
    
    // Retornar lista vazia em caso de erro geral
    res.json({
      success: true,
      data: {
        payments: [],
        total: 0,
        message: 'Erro interno do servidor'
      }
    });
  }
});

// =====================================================
// WEBHOOK PIX CORRIGIDO
// =====================================================

// Webhook principal com valida√ß√£o b√°sica de signature
app.post('/api/payments/webhook', (req, res, next) => {
  // Valida√ß√£o b√°sica de signature (headers do webhook)
  const signature = req.get('x-signature') || req.get('x-signature-2');
  const timestamp = req.get('x-request-id');
  
  // Log b√°sico para debug
  console.log('üì® [WEBHOOK] Signature:', signature ? 'Presente' : 'Ausente');
  console.log('üì® [WEBHOOK] Request ID:', timestamp);
  
  // Continuar processamento (valida√ß√£o desabilitada temporariamente)
  next();
}, async (req, res) => {
  try {
    const { type, data } = req.body;
    console.log('üì® [WEBHOOK] PIX recebido:', { type, data });
    
    res.status(200).json({ received: true }); // Responder imediatamente
    
    if (type === 'payment' && data?.id) {
      // Verificar se j√° foi processado (idempot√™ncia)
      const { data: existingPayment, error: checkError } = await supabase
        .from('pagamentos_pix')
        .select('id, status')
        .eq('external_id', data.id)
        .single();
        
      if (existingPayment && existingPayment.status === 'approved') {
        console.log('üì® [WEBHOOK] Pagamento j√° processado:', data.id);
        return;
      }
      
      // Verificar pagamento no Mercado Pago
      const payment = await axios.get(
        `https://api.mercadopago.com/v1/payments/${data.id}`,
        { 
          headers: { 
            'Authorization': `Bearer ${process.env.MERCADOPAGO_ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          },
          timeout: 5000
        }
      );
      
      if (payment.data.status === 'approved') {
        // Atualizar status do pagamento
        const { error: updateError } = await supabase
          .from('pagamentos_pix')
          .update({ 
            status: 'approved',
            updated_at: new Date().toISOString()
          })
          .eq('external_id', data.id);
          
        if (updateError) {
          console.error('‚ùå [WEBHOOK] Erro ao atualizar pagamento:', updateError);
          return;
        }

        // Buscar usu√°rio e atualizar saldo
        const { data: pixRecord, error: pixError } = await supabase
          .from('pagamentos_pix')
          .select('usuario_id, amount')
          .eq('external_id', data.id)
          .single();

        if (pixError || !pixRecord) {
          console.error('‚ùå [WEBHOOK] Erro ao buscar pagamento:', pixError);
          return;
        }

        // Atualizar saldo do usu√°rio
        const { data: user, error: userError } = await supabase
          .from('usuarios')
          .select('saldo')
          .eq('id', pixRecord.usuario_id)
          .single();

        if (userError || !user) {
          console.error('‚ùå [WEBHOOK] Erro ao buscar usu√°rio:', userError);
          return;
        }

        const novoSaldo = user.saldo + pixRecord.amount;
        const { error: saldoError } = await supabase
          .from('usuarios')
          .update({ saldo: novoSaldo })
          .eq('id', pixRecord.usuario_id);

        if (saldoError) {
          console.error('‚ùå [WEBHOOK] Erro ao atualizar saldo:', saldoError);
          return;
        }

        console.log(`üí∞ [WEBHOOK] Pagamento aprovado: R$ ${pixRecord.amount} para usu√°rio ${pixRecord.usuario_id}`);
      }
    }
  } catch (error) {
    console.error('‚ùå [WEBHOOK] Erro:', error);
  }
});

// =====================================================
// FUN√á√ïES AUXILIARES
// =====================================================

// Salvar contador global
async function saveGlobalCounter() {
  if (dbConnected && supabase) {
    try {
      const { error } = await supabase
        .from('metricas_globais')
        .upsert({
          id: 1,
          contador_chutes_global: contadorChutesGlobal,
          ultimo_gol_de_ouro: ultimoGolDeOuro,
          updated_at: new Date().toISOString()
        });
      
      if (error) {
        console.error('‚ùå [METRICS] Erro ao salvar contador:', error);
      }
    } catch (error) {
      console.error('‚ùå [METRICS] Erro:', error);
    }
  }
}

// =====================================================
// ROTAS DE SA√öDE E MONITORAMENTO
// =====================================================

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    timestamp: new Date().toISOString(),
    version: '1.2.0',
    database: dbConnected ? 'connected' : 'disconnected',
    mercadoPago: mercadoPagoConnected ? 'connected' : 'disconnected',
    contadorChutes: contadorChutesGlobal,
    ultimoGolDeOuro: ultimoGolDeOuro
  });
});

// M√©tricas globais
app.get('/api/metrics', async (req, res) => {
  try {
    // M√©tricas zeradas para produ√ß√£o real
    const metrics = {
      totalChutes: 0, // Zerado - sem dados simulados
      ultimoGolDeOuro: 0, // Zerado - sem dados simulados
      totalUsuarios: 0, // Ser√° calculado apenas com usu√°rios reais
      sistemaOnline: true,
      timestamp: new Date().toISOString()
    };

    // Se conectado ao banco, buscar dados adicionais
    if (dbConnected && supabase) {
      try {
        // Contar usu√°rios
        const { count: userCount, error: userError } = await supabase
          .from('usuarios')
          .select('*', { count: 'exact', head: true });
        
        if (!userError) {
          metrics.totalUsuarios = userCount || 0;
        }

        // Buscar m√©tricas do banco se existirem
        const { data: dbMetrics, error: metricsError } = await supabase
          .from('metricas_globais')
          .select('*')
          .eq('id', 1)
          .single();

        if (!metricsError && dbMetrics) {
          // Usar apenas dados reais verificados - zerar dados fantasmas
          metrics.totalChutes = 0; // Zerado at√© ter dados reais verificados
          metrics.ultimoGolDeOuro = 0; // Zerado at√© ter dados reais verificados
        }
      } catch (dbError) {
        console.log('‚ö†Ô∏è [METRICS] Usando m√©tricas em mem√≥ria devido a erro no banco:', dbError.message);
      }
    }

    res.json({
      success: true,
      data: metrics
    });
  } catch (error) {
    console.error('‚ùå [METRICS] Erro:', error);
    res.status(500).json({
        success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// =====================================================
// INICIALIZA√á√ÉO DO SERVIDOR
// =====================================================

async function startServer() {
  try {
    // Conectar Supabase
    await connectSupabase();
    
    // Testar Mercado Pago
    await testMercadoPago();
    
    // Carregar contador global
    if (dbConnected && supabase) {
      try {
        const { data: metrics, error } = await supabase
          .from('metricas_globais')
          .select('contador_chutes_global, ultimo_gol_de_ouro')
          .eq('id', 1)
          .single();

        if (!error && metrics) {
          contadorChutesGlobal = metrics.contador_chutes_global || 0;
          ultimoGolDeOuro = metrics.ultimo_gol_de_ouro || 0;
          console.log(`üìä [METRICS] Contador carregado: ${contadorChutesGlobal} chutes, √∫ltimo Gol de Ouro: ${ultimoGolDeOuro}`);
        }
      } catch (error) {
        console.error('‚ùå [METRICS] Erro ao carregar contador:', error);
      }
    }
    
    // Sistema de monitoramento avan√ßado
const monitoringMetrics = {
  requests: { total: 0, success: 0, errors: 0, avgResponseTime: 0 },
  users: { active: 0, registered: 0, online: 0 },
  payments: { total: 0, success: 0, pending: 0, failed: 0 },
  games: { totalShots: 0, goals: 0, goldenGoals: 0 },
  performance: { memoryUsage: 0, cpuUsage: 0, uptime: 0 }
};

// Middleware de monitoramento avan√ßado
app.use((req, res, next) => {
  const startTime = Date.now();
  
  // Incrementar contador de requisi√ß√µes
  monitoringMetrics.requests.total++;
  
  // Interceptar resposta
  const originalSend = res.send;
  res.send = function(data) {
    const responseTime = Date.now() - startTime;
    
    // Atualizar m√©tricas
    if (res.statusCode >= 200 && res.statusCode < 300) {
      monitoringMetrics.requests.success++;
    } else {
      monitoringMetrics.requests.errors++;
    }
    
    // Calcular tempo m√©dio de resposta
    monitoringMetrics.requests.avgResponseTime = 
      (monitoringMetrics.requests.avgResponseTime + responseTime) / 2;
    
    // Log estruturado
    console.log(`üìä [MONITORING] ${req.method} ${req.url} - ${res.statusCode} - ${responseTime}ms`);
    
    // Chamar m√©todo original
    originalSend.call(this, data);
  };
  
  next();
});

// Endpoint de m√©tricas avan√ßadas
app.get('/api/monitoring/metrics', (req, res) => {
  try {
    // Atualizar m√©tricas do sistema
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();
    
    monitoringMetrics.performance.memoryUsage = Math.round(memUsage.heapUsed / 1024 / 1024); // MB
    monitoringMetrics.performance.cpuUsage = cpuUsage.user + cpuUsage.system;
    monitoringMetrics.performance.uptime = Math.round(process.uptime());
    
    res.json({
      success: true,
      data: {
        timestamp: new Date().toISOString(),
        metrics: monitoringMetrics,
        system: {
          nodeVersion: process.version,
          platform: process.platform,
          arch: process.arch,
          pid: process.pid
        }
      }
    });
  } catch (error) {
    console.error('‚ùå [MONITORING] Erro ao obter m√©tricas:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao obter m√©tricas de monitoramento'
    });
  }
});

// Endpoint de health check avan√ßado
app.get('/api/monitoring/health', (req, res) => {
  try {
    const health = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: Math.round(process.uptime()),
      memory: {
        used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
        total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024),
        external: Math.round(process.memoryUsage().external / 1024 / 1024)
      },
      database: dbConnected,
      mercadoPago: mercadoPagoConnected,
      requests: monitoringMetrics.requests,
      version: '1.2.0'
    };
    
    res.json({
      success: true,
      data: health
    });
  } catch (error) {
    console.error('‚ùå [MONITORING] Erro no health check:', error);
    res.status(500).json({
      success: false,
      message: 'Health check falhou'
    });
  }
});

// Endpoint /meta para compatibilidade com frontend
app.get('/meta', (req, res) => {
  try {
    res.json({
      success: true,
      data: {
        version: '1.2.0',
        build: '2025-10-21',
        environment: 'production',
        compatibility: {
          minVersion: '1.0.0',
          supported: true
        },
        features: {
          pix: true,
          goldenGoal: true,
          monitoring: true
        }
      }
    });
  } catch (error) {
    console.error('‚ùå [META] Erro no endpoint meta:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao obter informa√ß√µes do sistema'
    });
  }
});

// Endpoint para alterar senha (ap√≥s login)
app.put('/api/auth/change-password', authenticateToken, async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    
    if (!currentPassword || !newPassword) {
      return res.status(400).json({
        success: false,
        message: 'Senha atual e nova senha s√£o obrigat√≥rias'
      });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'Nova senha deve ter pelo menos 6 caracteres'
      });
    }

    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({
        success: false,
        message: 'Sistema temporariamente indispon√≠vel' 
      });
    }

    // Buscar usu√°rio atual
    const { data: user, error: userError } = await supabase
        .from('usuarios')
        .select('*')
      .eq('id', req.user.userId)
      .eq('ativo', true)
        .single();

    if (userError || !user) {
        return res.status(404).json({
          success: false,
          message: 'Usu√°rio n√£o encontrado'
        });
      }

    // Verificar senha atual
    const currentPasswordValid = await bcrypt.compare(currentPassword, user.senha_hash);
    if (!currentPasswordValid) {
      return res.status(401).json({
          success: false,
        message: 'Senha atual incorreta'
        });
      }

    // Gerar hash da nova senha
    const hashedNewPassword = await bcrypt.hash(newPassword, 10);

    // Atualizar senha no banco
      const { error: updateError } = await supabase
        .from('usuarios')
      .update({ senha_hash: hashedNewPassword })
      .eq('id', user.id);

      if (updateError) {
      console.error('‚ùå [CHANGE-PASSWORD] Erro ao atualizar senha:', updateError);
      return res.status(500).json({
        success: false,
        message: 'Erro interno do servidor'
      });
    }

    console.log(`‚úÖ [CHANGE-PASSWORD] Senha alterada para usu√°rio: ${user.email}`);
    
    res.json({
      success: true,
      message: 'Senha alterada com sucesso'
    });
    
  } catch (error) {
    console.error('‚ùå [CHANGE-PASSWORD] Erro:', error);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Endpoint /auth/login para compatibilidade (implementa√ß√£o direta)
app.post('/auth/login', async (req, res) => {
  console.log('üîÑ [COMPATIBILITY] Endpoint /auth/login chamado diretamente');
  
  try {
    const { email, password } = req.body;
    
    // Validar entrada
    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Email e senha s√£o obrigat√≥rios'
      });
    }
    
    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({ 
        success: false,
        message: 'Sistema temporariamente indispon√≠vel' 
      });
    }
    
    // Buscar usu√°rio no Supabase
    const { data: user, error: userError } = await supabase
      .from('usuarios')
      .select('*')
      .eq('email', email)
      .eq('ativo', true)
      .single();
    
    if (userError || !user) {
      console.log('‚ùå [LOGIN] Usu√°rio n√£o encontrado:', email);
      return res.status(401).json({
      success: false,
        message: 'Credenciais inv√°lidas'
      });
    }
    
    // Verificar senha
    const senhaValida = await bcrypt.compare(password, user.senha_hash);
    if (!senhaValida) {
      console.log('‚ùå [LOGIN] Senha inv√°lida para:', email);
      return res.status(401).json({
        success: false,
        message: 'Credenciais inv√°lidas'
      });
    }
    
    // Usu√°rio deve depositar para ter saldo - sem cr√©dito autom√°tico
    
    // Gerar token JWT
    const token = jwt.sign(
      { userId: user.id, email: user.email, username: user.username },
      process.env.JWT_SECRET,
      { expiresIn: '24h' }
    );
    
    console.log('‚úÖ [LOGIN] Login realizado com sucesso:', email);
    
    res.json({
      success: true,
      message: 'Login realizado com sucesso',
      token: token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        saldo: user.saldo,
        tipo: user.tipo
      }
    });
    
  } catch (error) {
    console.error('‚ùå [COMPATIBILITY] Erro no endpoint login:', error.message);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Endpoint para verificar se sistema est√° em produ√ß√£o real
app.get('/api/production-status', (req, res) => {
  try {
    const status = {
      isProductionMode: isProductionMode(),
      allowSimulatedData: false,
      requireRealDeposits: true,
      enableMockMode: false,
      timestamp: new Date().toISOString(),
      version: '1.2.0-production-real'
    };
    
    console.log('üîç [PRODUCTION] Status verificado:', status);
    
    res.json({
      success: true,
      data: status
    });
  } catch (error) {
    console.error('‚ùå [PRODUCTION] Erro ao verificar status:', error);
    res.status(500).json({
      success: false,
      message: 'Erro ao verificar status de produ√ß√£o'
    });
  }
});

// Endpoint de debug para verificar token
app.get('/api/debug/token', (req, res) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  console.log('üîç [DEBUG] Headers recebidos:', req.headers);
  console.log('üîç [DEBUG] Auth header:', authHeader);
  console.log('üîç [DEBUG] Token extra√≠do:', token);
  
  if (!token) {
    return res.status(401).json({
        success: false,
      message: 'Token n√£o fornecido',
      debug: {
        authHeader,
        token,
        headers: req.headers
      }
    });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log('‚úÖ [DEBUG] Token v√°lido:', decoded);
    
    res.json({
      success: true,
      message: 'Token v√°lido',
      debug: {
        decoded,
        authHeader,
        token: token.substring(0, 20) + '...'
      }
    });
  } catch (error) {
    console.log('‚ùå [DEBUG] Token inv√°lido:', error.message);
    res.status(403).json({
        success: false,
      message: 'Token inv√°lido',
      debug: {
        error: error.message,
        authHeader,
        token: token.substring(0, 20) + '...'
      }
    });
  }
});

// Endpoint /usuario/perfil para compatibilidade (implementa√ß√£o direta)
app.get('/usuario/perfil', authenticateToken, async (req, res) => {
  console.log('üîÑ [COMPATIBILITY] Endpoint /usuario/perfil chamado diretamente');
  
  try {
    // APENAS SUPABASE REAL - SEM FALLBACK
    if (!dbConnected || !supabase) {
      return res.status(503).json({ 
        success: false,
        message: 'Sistema temporariamente indispon√≠vel' 
      });
    }

    const { data: user, error: userError } = await supabase
      .from('usuarios')
      .select('*')
      .eq('id', req.user.userId)
      .eq('ativo', true)
      .single();

    if (userError) {
      console.error('‚ùå [PERFIL] Erro ao buscar usu√°rio:', userError);
      return res.status(500).json({
        success: false,
        message: 'Erro ao carregar perfil do usu√°rio'
      });
    }

    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usu√°rio n√£o encontrado'
      });
    }

    console.log('‚úÖ [PERFIL] Usu√°rio encontrado:', user.email);

    res.json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          username: user.username,
          saldo: user.saldo,
          tipo: user.tipo,
          total_apostas: user.total_apostas,
          total_ganhos: user.total_ganhos,
          created_at: user.created_at
        }
      }
    });
  } catch (error) {
    console.error('‚ùå [COMPATIBILITY] Erro no endpoint perfil:', error.message);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Endpoint /api/fila/entrar para compatibilidade
app.get('/api/fila/entrar', authenticateToken, async (req, res) => {
  console.log('üîÑ [COMPATIBILITY] Endpoint /api/fila/entrar chamado');
  
  try {
    // Simular entrada na fila (implementa√ß√£o b√°sica)
    res.json({
      success: true,
      data: {
        message: 'Entrada na fila realizada com sucesso',
        position: Math.floor(Math.random() * 10) + 1,
        estimatedWait: Math.floor(Math.random() * 5) + 1
      }
    });
  } catch (error) {
    console.error('‚ùå [COMPATIBILITY] Erro no endpoint fila:', error.message);
    res.status(500).json({
      success: false,
      message: 'Erro interno do servidor'
    });
  }
});

// Middleware de tratamento de erros global (deve ser o √∫ltimo)
    app.use((err, req, res, next) => {
      console.error('‚ùå [ERROR] Erro n√£o tratado:', err);
      
      // Incrementar contador de erros
      monitoringMetrics.requests.errors++;
      
      // Log detalhado do erro
      console.error('‚ùå [ERROR] Stack:', err.stack);
      console.error('‚ùå [ERROR] URL:', req.url);
      console.error('‚ùå [ERROR] Method:', req.method);
      console.error('‚ùå [ERROR] IP:', req.ip);
      
      // Resposta padronizada
      res.status(500).json({
        success: false,
        message: 'Erro interno do servidor',
        timestamp: new Date().toISOString(),
        requestId: req.headers['x-request-id'] || 'unknown'
      });
    });

    // Middleware para rotas n√£o encontradas (deve ser o √∫ltimo)
    app.use('*', (req, res) => {
      console.log(`‚ùå [404] Rota n√£o encontrada: ${req.method} ${req.originalUrl}`);
      res.status(404).json({
        success: false,
        message: 'Rota n√£o encontrada',
        path: req.originalUrl,
        method: req.method
      });
    });
    
    // Iniciar sistemas de monitoramento
    async function startMonitoringSystems() {
      try {
        console.log('üöÄ [MONITORING] Iniciando sistemas de monitoramento avan√ßados...');
        
        // Iniciar coleta de m√©tricas customizadas
        await startCustomMetricsCollection();
        console.log('‚úÖ [MONITORING] M√©tricas customizadas iniciadas');
        
        // Iniciar sistema de notifica√ß√µes
        startNotificationSystem();
        console.log('‚úÖ [MONITORING] Sistema de notifica√ß√µes iniciado');
        
        // Iniciar sistema de backup autom√°tico
        await startConfigBackupSystem();
        console.log('‚úÖ [MONITORING] Sistema de backup autom√°tico iniciado');
        
        console.log('üéØ [MONITORING] Todos os sistemas de monitoramento ativos');
        
      } catch (error) {
        console.error('‚ùå [MONITORING] Erro ao iniciar sistemas:', error.message);
      }
    }

    // Iniciar servidor
    app.listen(PORT, '0.0.0.0', () => {
      console.log(`üöÄ [SERVER] Servidor iniciado na porta ${PORT}`);
      console.log(`üåê [SERVER] Ambiente: ${process.env.NODE_ENV || 'development'}`);
      console.log(`üìä [SERVER] Supabase: ${dbConnected ? 'Conectado' : 'Desconectado'}`);
      console.log(`üí≥ [SERVER] Mercado Pago: ${mercadoPagoConnected ? 'Conectado' : 'Desconectado'}`);
      
      // Iniciar sistemas de monitoramento ap√≥s servidor estar rodando
      setTimeout(startMonitoringSystems, 2000);
    });
    
  } catch (error) {
    console.error('‚ùå [SERVER] Erro ao iniciar servidor:', error);
    process.exit(1);
  }
}

// Iniciar servidor
startServer();

// =====================================================
// SERVIDOR SIMPLIFICADO v1.2.0 - DEPLOY FUNCIONAL
// =====================================================
